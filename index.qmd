---
title: "Document Search Output Anonymiser"
filters:
  - shinylive
format:
  html:
    page-layout: full
    embed-resources: false
---

```{shinylive-r}
#| standalone: true
#| viewerHeight: 800

library(shiny)
library(stringdist)

# ----------------------------
# Helper functions
# ----------------------------

upload_original_data <- function(selected_file) {
  if (file.size(selected_file) == 0) {
    stop("The selected file is empty.")
  }

  original_data <- read.csv(selected_file, check.names = TRUE)

  if (nrow(original_data) == 0) {
    stop("The selected file has no data rows.")
  }

  text_cols <- sapply(original_data, is.character)

  if (sum(text_cols) < 2) {
    stop("The file must contain at least two text columns.")
  }

  original_data
}


create_name_keys <- function(original_names, col_name) {
  original_names[is.na(original_names)] <- ""

  x <- original_names
  x <- gsub("([a-z])([A-Z])", "\\1 \\2", x)
  x <- gsub("-", " ", x)
  x <- tolower(x)
  x <- gsub("\\s*['\"].*?['\"]\\s*", "", x)
  x <- gsub("[[:punct:]]", "", x)
  x <- trimws(x)
  x <- gsub("\\s+", " ", x)
  x <- gsub("(?i)^(master|mrs|mr|miss|ms|dr)\\s+", "", x)

  if (!is.null(col_name)) {
    x[x == ""] <- paste0("x ", col_name)
  }

  words <- strsplit(x, "\\s+")
  first_initial <- vapply(words, function(w) substr(w[1], 1, 1), character(1))
  last_word     <- vapply(words, function(w) w[length(w)], character(1))

  paste0(first_initial, last_word)
}


calculate_distance_between_name_key_pairs <- function(df,
                                                      patient_key_col = "patient_key",
                                                      sender_key_col  = "sender_key") {
  df$distance <- stringdist::stringdist(
    df[[patient_key_col]],
    df[[sender_key_col]],
    method = "osa"
  )
  df
}


filter_by_threshold <- function(df, threshold) {
  df[df$distance >= threshold, , drop = FALSE]
}

# ----------------------------
# UI
# ----------------------------

ui <- fluidPage(
	
	tags$head(
  tags$script(HTML("
    function downloadCSV(csvText, filename) {
      const blob = new Blob([csvText], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);

      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', filename);

      document.body.appendChild(link);
      link.click();

      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    Shiny.addCustomMessageHandler('downloadCSV', function(message) {
      downloadCSV(message.csv, message.filename);
    });
  "))
),


  titlePanel(
    tagList(
      tags$h2("Document Search Output Anonymiser"),
      tags$hr()
    )
  ),

  sidebarLayout(

    sidebarPanel(
      fileInput(
        "file_upload",
        "Step 1: Choose a CSV file",
        accept = ".csv"
      ),

      tags$br(),

      uiOutput("patient_column_selector"),
      uiOutput("sender_column_selector"),

      tags$br(),

      uiOutput("process_button"),

      tags$br(),

      uiOutput("post_process_ui")
    ),

    mainPanel(
      uiOutput("table_title"),
      tableOutput("main_table")
    )
  )
)

# ----------------------------
# Server
# ----------------------------

# ----------------------------
# Server: Processing + JS download
# ----------------------------

server <- function(input, output, session) {

  # Reactive: uploaded data
  original_data <- reactive({
    req(input$file_upload)
    tryCatch(
      upload_original_data(input$file_upload$datapath),
      error = function(e) {
        showNotification(e$message, type = "error", duration = 10)
        NULL
      }
    )
  })

  # Step 2: Patient column selector
  output$patient_column_selector <- renderUI({
    df <- original_data()
    req(df)
    char_cols <- names(df)[sapply(df, is.character)]
    selectInput(
      "patient_col",
      "Step 2: Select Patient Column",
      choices = c("— Select column —" = "", char_cols),
      selected = ""
    )
  })

  # Step 3: Sender column selector
  output$sender_column_selector <- renderUI({
    req(input$patient_col != "")
    df <- original_data()
    char_cols <- names(df)[sapply(df, is.character)]
    sender_choices <- setdiff(char_cols, input$patient_col)
    selectInput(
      "sender_col",
      "Step 3: Select Sender Column",
      choices = c("— Select column —" = "", sender_choices),
      selected = ""
    )
  })

  # Step 4: Process button
  output$process_button <- renderUI({
    req(input$sender_col != "")
    actionButton("process", "Step 4: Process")
  })

  # Reactive: Processed data
  processed_data <- eventReactive(input$process, {
    df <- original_data()
    out <- data.frame(
      row_id  = seq_len(nrow(df)),
      patient = df[[input$patient_col]],
      sender  = df[[input$sender_col]],
      stringsAsFactors = FALSE
    )
    out$patient_key <- create_name_keys(out$patient, "patient")
    out$sender_key  <- create_name_keys(out$sender, "sender")
    calculate_distance_between_name_key_pairs(out)
  })

  # Step 5: Threshold slider and JS download button
  output$post_process_ui <- renderUI({
    req(processed_data())
    tagList(
      sliderInput("threshold", "Step 5: Matching threshold", 0, 5, 0, 1),
      actionButton("download_js", "Step 6: Download anonymised CSV")
    )
  })

  # Reactive: Filtered/anonymised data
  anonymised_data <- reactive({
    req(processed_data(), input$threshold)
    filtered <- filter_by_threshold(processed_data(), input$threshold)
    keep <- filtered$row_id
    df <- original_data()[keep, , drop = FALSE]
    df[[input$patient_col]] <- NULL
    df
  })

  # Table title
  output$table_title <- renderUI({
    if (is.null(input$process)) h4("Preview of uploaded data")
    else h4("Processed data preview")
  })

  # Table preview
  output$main_table <- renderTable({
    if (is.null(input$process)) head(original_data(), 50)
    else head(anonymised_data(), 50)
  })

  # ----------------------------
  # JavaScript download
  # ----------------------------
  observeEvent(input$download_js, {
    csv_text <- paste(
      capture.output(
        write.csv(anonymised_data(), row.names = FALSE)
      ),
      collapse = "\n"
    )
    filename <- paste0(tools::file_path_sans_ext(input$file_upload$name),
                       "_anonymised.csv")
    session$sendCustomMessage(
      "downloadCSV",
      list(csv = csv_text, filename = filename)
    )
  })
}



shinyApp(ui, server)

```
