---
title: "Document Search Output Anonymiser"
filters:
  - shinylive
format:
  html:
    page-layout: full
    embed-resources: false
execute: 
  cache: false
    
---

```{shinylive-r}
#| standalone: true
#| viewerHeight: 1200

library(shiny)
library(DT)

# HELPER FUNCTIONS ####
upload_data <- function(datapath) {
    
    if(!file.exists(datapath)) {
        stop("Selected file does not exist.")
    }
    
    if (file.size(datapath) == 0) {
        stop("The selected file is empty and contains no data.")
    }
    
    df <- read.csv(datapath, check.names = TRUE)
    
    if (nrow(df) == 0) {
        stop("The selected file contains column names but no data rows.")
    }
    
    n_char_cols <- sum(vapply(df, is.character, logical(1)))

    if (n_char_cols < 2) {
        stop("The selected file must contain at least two valid text columns for matching.")
    }
    
    return(df)
}

make_scrolling_table <- function(table) {
    
    stopifnot(is.data.frame(table))
    
    DT::datatable(
        table,
        rownames = TRUE,
        options = list(
            scrollY = "600px",
            scrollX = TRUE,
            paging = FALSE,
            dom = "t"
        )
    )
}

create_name_keys <- function(original_names, col_name = NULL) {
    
    # standardise format
    original_names[is.na(original_names)] <- ""
    
    step_split_case    <- gsub("([a-z])([A-Z])", "\\1 \\2", original_names)
    step_split_hyphen  <- gsub("-", " ", step_split_case)
    step_lower         <- tolower(step_split_hyphen)
    step_no_quotes     <- gsub("\\s*['\"].*?['\"]\\s*", "", step_lower)
    step_no_punct      <- gsub("[[:punct:]]", "", step_no_quotes)
    step_trimmed       <- trimws(step_no_punct)
    step_single_spaces <- gsub("\\s+", " ", step_trimmed)
    standardised_names <- gsub("(?i)^(master|mrs|mr|miss|ms|dr)\\s+",
                               "", step_single_spaces)
    
    # handle empty strings (includes missing values)
    if (!is.null(col_name)) {
        placeholder <- paste0("x ", col_name)
        standardised_names[standardised_names == ""] <- placeholder
    }
    
    # produce keys from initial of first word and last word
    words <- strsplit(standardised_names, "\\s+")
    
    first_initial <- vapply(words, function(x)
        substr(x[1], 1, 1), FUN.VALUE = character(1))
    
    last_word <- vapply(words, function(x) 
        x[length(x)], FUN.VALUE = character(1))
    
    paste0(first_initial, last_word)
}

calculate_distance_between_name_key_pairs <- function(patient_vec, sender_vec, method = "osa") {
    
    if (length(patient_vec) != length(sender_vec)) {
        stop("patient_vec and sender_vec must be the same length")
    }
    if (any(is.na(patient_vec)) || any(patient_vec == "")) {
        stop("patient_vec contains NA or empty strings")
    }
    if (any(is.na(sender_vec)) || any(sender_vec == "")) {
        stop("sender_vec contains NA or empty strings")
    }
    
    stringdist::stringdist(patient_vec, sender_vec, method = method)
}

anonymise_data <- function(df,
                           matched_rows,
                           anonymisation_method,
                           sender_column,
                           patient_column) {
    
    if (anonymisation_method == "Remove Matched Records") {
        df <- df[-matched_rows, , drop = FALSE]
        
    } else if (anonymisation_method == "Keep Matched Records") {
        df[[sender_column]][matched_rows] <- "Patient"
    }
    
    # Always drop patient column
    if (patient_column %in% names(df)) {
        df[[patient_column]] <- NULL
    }
    
    df
}

download_csv_js <- function() {
    # download file from the browser with no server (shinylive deployment)
    "
        function downloadCSV(csvText, filename) {
          const blob = new Blob([csvText], { type: 'text/csv;charset=utf-8;' });
          const url = URL.createObjectURL(blob);

          const link = document.createElement('a');
          link.setAttribute('href', url);
          link.setAttribute('download', filename);

          document.body.appendChild(link);
          link.click();

          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        }

        Shiny.addCustomMessageHandler('downloadCSV', function(message) {
          downloadCSV(message.csv, message.filename);
        });
    "
}



# USER INTERFACE (UI) ####

ui <- fluidPage(
    tags$head(tags$script(HTML(download_csv_js()))),
    sidebarLayout(
        sidebarPanel(
            uiOutput("file_upload"),
            uiOutput("patient_column_selector"),
            uiOutput("sender_column_selector"),
            uiOutput("compare_names_button"),
            tags$br(),
            uiOutput("matching_threshold_slider"),
            uiOutput("anonymise_data"),
            tags$br(),
            uiOutput("download_button")
            ),
        mainPanel(
            uiOutput("table_title"), 
            DT::DTOutput("main_table"))
        )
    )

# SERVER ####

server <- function(input, output, session) {
    
    output$file_upload <- renderUI({
        if (!is.null(input$compare_names) && input$compare_names > 0) {
            tagList(
                tags$label(style = "font-weight: 600;", 
                           "Step 1: To process a new file, please refresh the browser."),
                tags$br(),
                tags$br()
            )
            
        } else {
            fileInput(
                "selected_file",
                "Step 1: Upload CSV file", 
                buttonLabel = "Select...",
                accept = c(".csv")
            )
        }
    })

    # Upload Raw Data
    raw_data <- reactive({
        req(input$selected_file)
        upload_data(input$selected_file$datapath)
    })
    
    # Display Data Table
    
    table_state <- reactive({
        
        if (!is.null(input$anonymise) && input$anonymise > 0) {
            list(
                title = "Anonymised Data",
                data  = anonymised_raw_data()
            )
            
        } else if (!is.null(input$compare_names) && input$compare_names > 0) {
            list(
                title = "Name pairs sorted by similarity (high to low)",
                data  = filtered_name_data()
            )
            
        } else {
            list(
                title = "Preview of raw data",
                data  = head(raw_data(), 50)
            )
        }
    })
    
    output$table_title <- renderUI({
        state <- table_state()
        tags$h4(state$title)
    })
    
    output$main_table <- DT::renderDT({
        state <- table_state()
        make_scrolling_table(state$data)
    })
    
    
    # Identify 'Patient' Column
    output$patient_column_selector <- renderUI({
        req(raw_data())
        df <- raw_data()
        char_cols <- names(df)[sapply(df, is.character)]
        selectInput(
            "patient_column",
            "Step 2: Identify Patient Column",
            choices  = c("— Select column —" = "", char_cols),
            selected = ""
        )
    })
    
    # Identify Sender column
    output$sender_column_selector <- renderUI({
        req(input$patient_column != "")
        df <- raw_data()
        char_cols <- names(df)[sapply(df, is.character)]
        sender_choices <- setdiff(char_cols, input$patient_column)
        selectInput(
            "sender_column",
            "Step 3: Identify Sender Column",
            choices  = c("— Select column —" = "", sender_choices),
            selected = ""
        )
    })
    
    # Compare names 
    output$compare_names_button <- renderUI({
        req(input$sender_column)
        tagList(
            tags$label(style = "font-weight: 600;", 
                       "Step 4: Compare Names"),
            tags$br(),
            actionButton("compare_names", "Click Here")
        )
    })
    
    name_comparison_data <- reactive({
        
        req(input$compare_names)
        
        df <- data.frame(
            row_id = seq_len(nrow(raw_data())),
            patient = raw_data()[[input$patient_column]],
            sender  = raw_data()[[input$sender_column]],
            stringsAsFactors = FALSE
        )
        
        df$patient_key <- create_name_keys(df$patient, "patient")
        df$sender_key  <- create_name_keys(df$sender, "sender")
        
        # Compute distance vector and attach
        df$distance <- calculate_distance_between_name_key_pairs(df$patient_key, df$sender_key)
        
        df
        
    })

    output$matching_threshold_slider <- renderUI({
        req(input$compare_names)
        
        tagList(
            tags$label(style = "font-weight: 600;", 
                       "Step 5: Match Names"),
            tags$p("Adjust slider until no sender names match patient names"),
            sliderInput(
            "matching_threshold",
            label = "",
            min = 0, max = 5, value = 0, step = 1
            ))
    })
    
    filtered_name_data <- reactive({
        req(name_comparison_data(), input$matching_threshold)
        
        df <- name_comparison_data()
        df <- df[order(df$distance), , drop = FALSE]
        df <- df[df$distance >= input$matching_threshold, , drop = FALSE]       
        df <- df[, c("patient", "sender")]
        df
        })
    
    output$anonymise_data <- renderUI({
        req(filtered_name_data())
        
        tagList(
            radioButtons(
                "anonymisation_method", "Step 6: Anonymise Data", 
                choices = c("Remove Matched Records", "Keep Matched Records")),
            actionButton("anonymise", "Apply")
        )
    })
    
    matched_rows <- reactive({
        req(name_comparison_data(), input$matching_threshold)
        
        name_comparison_data()$row_id[
            name_comparison_data()$distance < input$matching_threshold
        ]
    })
    
    anonymised_raw_data <- reactive({
        
        req(input$anonymise)
        
        anonymise_data(
            df = raw_data(),
            matched_rows = matched_rows(),
            anonymisation_method = input$anonymisation_method,
            sender_column = input$sender_column,
            patient_column = input$patient_column
        )
    })
    
    output$download_button <- renderUI({
        req(anonymised_raw_data())
        tagList(
            tags$label(style = "font-weight: 600;", "Step 7: Download Anonymised Data"),
            tags$br(),
            actionButton("download_anonymised_js", "Download")
        )
    })
    
    observeEvent(input$download_anonymised_js, {
        req(anonymised_raw_data())
        
        csv_text <- paste(
            capture.output(
                write.csv(anonymised_raw_data(), row.names = FALSE)
            ),
            collapse = "\n"
        )
        
        filename <- paste0(
            tools::file_path_sans_ext(input$selected_file$name),
            "_anonymised.csv"
        )
        
        session$sendCustomMessage(
            "downloadCSV",
            list(csv = csv_text, filename = filename)
        )
    })
}

shinyApp(ui, server)

```
